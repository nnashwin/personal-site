{{define "title"}}Which Framework Do I Choose? | Tyler Boright{{end}}
{{define "body"}}
    <h2>A Leetcode without Struggle</h2>
    <small>2020-09-11</small>
    <p>From the beginning of my development career, I have struggled with algorithmic questions.</p>
    <p>Coding the correct solution within constraints under a certain time limit was impossible.  Most of the time, even thinking of a sub-optimal solution was tough.  Because of this ineptitude, I failed many interviews at companies I wanted to work at.</p>
    <p>For the longest time, I felt this was a reflection of innate inability.  I could not solve algorithmic questions because I was not smart enough.  Or I could not grasp algorithm questions because I did not go to school and take advanced classes.</p>
    <p>Even when I would solve a complex problem in my personal projects, it took me a long time.  I would spend days or weeks researching which algorithms worked in a certain scenario.</p>
    <p>I often would supplement a simpler method that could be iterated on quickly rather than taking the time to implement the more optimal, complicated one. </p>
    <p>After a few bad experiences, I even grew to dread the idea of interviewing at new companies.</p>
    <p>So during my long covid half-sabbatical in Taiwan, I decided to devote myself to improving this weakness as best I could.</p>
    <h3>The Plan</h3>
    <p>My initial plan was to set a goal of number of problems to practice starting from June until the end of the year.  I would complete 200 problems and formulate all new knowledge into Spaced Repetition for long-term memorization.</p>
    <p>Having never prepared for tech interviews in a focused manner, I went in completely blind.  The only intuition I had was that algorithmic interviews seemed to be a more in-depth look at competitive programming problems, and that some people spent long periods of their youth training to win these types of competitions.</p>
    <p>My number one goal from this journey was to reach a point where I would start to enjoy the algorithmic problem solving process.  I enjoy learning, but {any period of time I spent solving algorithm problems in the past usually ended up with me feeling angry.}</p>
    <p>After reaching 200, I can say that I enjoy the process much more than when I started.  I know that I can continue to gain algorithmic problem solving skills indefinitely with much less friction than before.</p>
    <p>The following is a rhuberic I recommend anyone trying to gain these skills while remaining sane. While this might not get you into a FAANG company in X months, it will help you develop habits that lead to building the necessary skills to feel confident interviewing.</p>
    <h3>Start from the Bottom</h3>
    <p>Start with easy problems.  Whether you use Leetcode, Codeforces, or some other platform, start working through some of the easiest problems on the platform.</p>
    <p>Starting with the easiest problems builds knowledge about the platform itself.  This approach exposes you to a broad range of topics, ideas, and tricks that can be used to optimize your solutions.  Starting with easy problems builds your confidence and lets you experience the sweet feeling of implementing an accepted solution.</p>
    <p>Just know that easy really means easy in the algorithmic problem solving domain.</p>
    <p>Even if you have a CS degree, many of the topics will most likely feel new or unfamiliar. Even if the approaches are familiar, if you have not solved similar problems in some time, you might struggle with the applications.</p>
    <p>For a beginner, you can gain algorithmic knowledge even from easy questions.  So start with easy.</p>
    <p>If you get to a point where you can solve 80%+ of the easy problems quickly with either the most optimal or near-optimal solution, jump into medium.</p>
    <h3>Read more Than You Write</h3>
    <p>This will apply more to people who do not have as much experience with competitive programming.  For every problem you solve, read the editorials to 3 - 5 more. Learn the algorithmic techniques that can be used to solve those types of problems.</p>
    <p>This approach works because there are multiple skills required to solve an algorithmic problem.  Basic algorithm and data structure knowledge, such as what constitutes good time complexities and in what general situations you can use specific patterns, are ones we talk about often in interview prep.</p>
    <p>Implementation of those data structures and algorithms in your preferred programming language is another skill we often touch on. However, for programmers who have been developing for a few years, the gaps in implementation knowledge tend to be less than those in algorithmic knowledge.</p>
    <p>Depending on the area in programming in which you work, you tend to never touch the breadth of algorithmic knowledge you will need to ace interviews.</p>
    <p>When prepping for interviews, it should be more effective for you to grok a large number of approaches rather than spending that time learning the approach and the exact implementation of a smaller number of problems.</p>
    <p>Learning to match algorithm patterns you know to novel problems will help you to build your problem solving skills.  Using this technique, you will iterate faster over larger amounts of problems and see which approaches best fit certain types of problems.</p>
    <h3>Work by Topic and By Random</h3>
    <p>I like to mix practice between working through a specific topic of problem to learn patterns and choosing random problems from any topic.</p>
    <p>You need both approaches in order to build general problem solving skill.  Memorizing answers for specific questions will only marginally increase your chance of success.</p>
    <p>Memorizing approaches and derivation steps will help you to apply your skills to a broader range of problems.</p>
    <p>Working on many problems in a related topic solidifies individual approaches to solving a particular type of problem. If you build specific skills through solving by topic while testing yourself through solving randomly asked questions, eventually you will hit a point where you have a general understanding on how to approach most problems.</p>
    <p>The more concepts you grok, the more problem types you will be able to solve.</p>
    <h3>Work hard and then view the answers</h3>
    <p>{When approaching a problem, I usually know within the first few minutes whether or not I know how to solve it. If I can't immediately think of an approach, I try to draw out the problem and figure out what I do know.</p>
    <p>While doing this, I think of any approach I can use to solve the problem--even a sub-optimal one.</p>
    <p>Sometimes, I can't think of anything.  My mind is blank, and every type of approach I can think of seems to not apply to the question.}</p>
    <p>When I am not testing myself on a timer, I will leave my desk and give myself some time to mull over the problem.</p>
    <p>Spending only a few minutes away can often allow for a previous insight or concept to bubble up into your focus and solve the problem. I sometimes come back with this intuition can work things out a bit further than I could when I left.</p>
    <p>After repeating this process a couple of times, if I have no forward traction for 10+ minutes, I will then consult some discussion page or editorial.  As mentioned above, I then try to learn as many potential approaches as possible from the editorial.</p>
    <h3>How You Will Progress</h3>
    <p>Through practicing 200+ problems I gained a few insights:</p>
    <p>1. Even for new problems, I frequently have an intuition of an approach to use after an initial read through the prompt.</p>
    <p>2. The feeling of not having any idea on how to solve a problem decreases the more topics you understand deeply.  There are patterns to be found in each topic.  In order to grok these patterns, you must first work deep into a topic so that you will see most of a pattern's permutations.</p>
    <p>3. If I am not being tested or in an interview, sometimes it is helpful to work on a problem, get stuck, then leave the problem be for a bit.  After some time, I try a different approach to the problem and am always closer to solving it than when I started. Even if I don't end up solving the problem with current knowledge, making some spaced practice highlights these gaps in knowledge.</p>
    <p>4. Solidifying problem concepts and insights in spaced repetition can be really helpful.  The benefits of using spaced repetition are best seen when working on these types of problems over months or years.</p>
    <h3>Final Word</h3>
    <p>You will not become better at programming interviews by building personal projects.</p>
    <p>In some circumstances, the algorithmic knowledge you learn from competitive programming will be useful in your job.  But you must have the knowledge of the concepts represented in a way that is generally applicable to many types of problems.</p>
    <p>Memorizing an approach to a problem is a good strategy.  Sometimes this memory comes from memorizing the answer to many similar problems that have the same approach.  It is best to memorize why a certain approach solves these types of problems rather than the exact solution to a particular problem.</p>
    <p>Not being able to solve an easy problem on a coding platform doesn't make you a bad engineer.  Disconnect your day job with the interview process.</p>
    <p>Many genius competitive programmers are hacky engineers. It is reasonable for many great developers to be shitty competitive programmers.  If you want to get better at algorithm problems, consistently spend time solving algorithm problems.</p>
    <p>Learning gradually can produce incredible results.  Remember, most of us overestimate what we can learn in a year and underestimate what we can learn in 10.  To see real results, stay calm and keep slowly building your web of algorithmic knowledge.</p>
{{end}}
